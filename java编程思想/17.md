# 第十七章 容器深入研究 #

Collections.nCopies();//返回的是Collections的private内部类CopiesList，该内部类的底层实现是一个对象和容器大小，使用的时候直接返回该类对象。 

    private static class CopiesList<E>
        extends AbstractList<E>
        implements RandomAccess, Serializable
    {
        private static final long serialVersionUID = 2739099268398711800L;

        final int n;
        final E element;

        CopiesList(int n, E e) {
            assert n >= 0;
            this.n = n;
            element = e;
        }
        ...
        public Object[] toArray() {
            final Object[] a = new Object[n];
            if (element != null)
                Arrays.fill(a, 0, n, element);
            return a;
        }
    }

AbstractList类的两个抽象方法：get()和size()，get()在AbstractList内部迭代器中的next()中被调用，返回当前遍历的值。
size()：返回当前List的大小。

LinkedHashMap使用散列表和双向链表两种方式共同表示同一组数据，在双向链表结构中新加入的数据存放到链表尾部，散列表使用HashMap存放。双向链表由于迭代器LinkedHashIterator。

HashSet底部存储使用的是HashMap。

LinkHashSet底部存储底部使用的是LinkHashMap。

TreeMap使用红黑树实现，其中的迭代器使用中序遍历。

SortedSet按对象的比较函数对元素进行排列，即元素继承Comparable或容器中使用Comparator。

Queue中add(),remove(),element()，如果添加或取出的为null，则抛出异常，offer(),poll(),peek()则不会抛出异常，会返回null或false。

ArrayBlockingQueue底层是数组实现，调用构造函数时规定数组的大小。存放和取都是从小到大循环。

PriorityQueue底部实现是Object数组，但该数组表示一个二叉树，该数组可以扩展。[结构参考](https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html) 

LinkedList实现Deque接口，是一个双向列表，可以向队头添加，也可向队尾添加。

Map集合中的key值对象的hashcode()和equals()要根据自己的需要来重写，默认的是根据对象地址来区分。

四种集合：Map,	List, Set, Queue这是四种不同的接口，接口有很多不同的实现——底层的数据结构不相同。性能各有优劣，要根据集合的优劣来选择实现的使用。






