# 第十七章 容器深入研究 #

Collections.nCopies();//返回的是Collections的private内部类CopiesList，该内部类的底层实现是一个对象和容器大小，使用的时候直接返回该类对象。 

    private static class CopiesList<E>
        extends AbstractList<E>
        implements RandomAccess, Serializable
    {
        private static final long serialVersionUID = 2739099268398711800L;

        final int n;
        final E element;

        CopiesList(int n, E e) {
            assert n >= 0;
            this.n = n;
            element = e;
        }
        ...
        public Object[] toArray() {
            final Object[] a = new Object[n];
            if (element != null)
                Arrays.fill(a, 0, n, element);
            return a;
        }
    }

AbstractList类的两个抽象方法：get()和size()，get()在AbstractList内部迭代器中的next()中被调用，返回当前遍历的值。
size()：返回当前List的大小。

LinkedHashMap使用散列表和双向链表两种方式共同表示同一组数据，在双向链表结构中新加入的数据存放到链表尾部，散列表使用HashMap存放。双向链表由于迭代器LinkedHashIterator。

HashSet底部存储使用的是HashMap。

LinkHashSet底部存储底部使用的是LinkHashMap。

TreeMap使用红黑树实现，其中的迭代器使用中序遍历。

SortedSet按对象的比较函数对元素进行排列，即元素继承Comparable或容器中使用Comparator。

Queue中add(),remove(),element()，如果添加或取出的为null，则抛出异常，offer(),poll(),peek()则不会抛出异常，会返回null或false。

ArrayBlockingQueue底层是数组实现，调用构造函数时规定数组的大小。存放和取都是从小到大循环。

PriorityQueue底部实现是Object数组，但该数组表示一个二叉树，该数组可以扩展。[结构参考](https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html) 

LinkedList实现Deque接口，是一个双向列表，可以向队头添加，也可向队尾添加。

Map集合中的key值对象的hashcode()和equals()要根据自己的需要来重写，默认的是根据对象地址来区分。

四种集合：Map,	List, Set, Queue这是四种不同的接口，接口有很多不同的实现——底层的数据结构不相同。性能各有优劣，要根据集合的优劣来选择实现的使用。

ArrayList存放的速度比LinkedList快，但插入和删除的速度慢。

基准测试：给定时间（该时间较小），看运行的次数。

HashSet总体性能比TreeSet要好，TreeSet内部维持一个排序状态，所以TreeSet变量速度快一些。而LinkedHashSet的插入操作代价更高，这是维护链表的额外开销。

IdentityHashMap底部实现是数组，位置i表示key，位置i+1表示value，key值是否相等使用的是==而不是equals()。扩容为原来的2倍，初始容量为32(l6*2)。

HashMap初始容量16，负载因子0.75，扩容为原来的2倍（hash值左移一位）。

String.CASE_INSENSITIVE_ORDER的值为CaseInsensitiveComparator，以字符串长度进行比较。



