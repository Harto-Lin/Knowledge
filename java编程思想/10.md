# 第十章 内部类 #
只有内部类才能声明为静态的，外部类如果使用static修饰，会报错。静态内部类不会持有外部类的对象引用，也可单独实例化；非静态内部类则持有外部对象的引用，在外部对象创建对象之后才可创建对象；静态内部类可以当成普通的类，只不过它在类里边声明。非静态内部类中不能有静态的出现，内部类中如果有静态的声明，则内部类也是静态的。  

&emsp;&emsp;1.非静态内部类能直接调用外部类的成员变量，是因为内部类持有外部类的对象引用。
  
&emsp;&emsp;2.非静态内部类使用.this是为了区分内部类的this和外部类的this。非静态内部类的对象必须使用外部类的对象.new来创建，同时内部类自动连接外部类的对象。  

&emsp;&emsp;3.实现接口的private内部类，在客户端可向上转型来调用公共方法，但得到的基类引用却不能向下转型来得到private内部类的引用，所以在客户端看来实现了接口的private类中扩展的方法是没有价值的。  

&emsp;&emsp;4.匿名内部类是new后边类的子类，使用的时候自动向上转型；匿名内部类没法重写或重载构造方法，因为没有类名，能通过语法块进行初始化（实例初始化）；接口里不可放任意代码，但可以放嵌套类，在接口里的内部类都是被static声明的，无论static是否被书写。  

&emsp;&emsp;5.内部类实现系统重启（数组重新复制，重新循环）。211页  

&emsp;&emsp;6.内部类的继承：内部类的构造器需要一个指向外部类的引用，所以在内部类的子类的构造器中需要一个指向外部类类型的引用，一般使用enclosingClassReference.super()这个语法。  

&emsp;&emsp;7.内部类的覆盖：    
&emsp;&emsp;当一个类A中含有内部类，当新建一个类B继承类A，并在类B中重写内部类时，其实只是新建了一个类，并没有产生覆盖，和字段相似。  

&emsp;&emsp;8.局部内部类和匿名内部类相似，可以向上转型为父引用，但父引用不能向下转型成该内部类，但它可以有构造方法，也可重载，同时可以new多个对象。  

匿名内部类是因为没有名字没法寻找，局部内部类是因为作用域问题没法调用。