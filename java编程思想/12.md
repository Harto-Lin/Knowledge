# 第十二章 通过异常处理错误 #
1. java中的异常处理是当每次调用可能出现异常的代码（有throw的代码），要对代码进行检查，防止抛出异常。使异常在同一个地方可被处理（catch代码块），简化了异常的处理。  

2. java的异常处理机制是终结型的——即异常产生就表示错误无法挽回，不能返回到异常产生的地方（恢复模型通过while可实现try的调用，但代码编写复杂，维护困难，不通用，所以不适用）。  
  
3. 异常说明使用throws，表示方法可能会抛出异常，当方法抛出异常时，调用该方法的方法要么处理该异常，要么变成异常方法。这种异常被称为被检查异常（不包括RuntimeException编程错误，即程序员自己的错误）。

4. 异常会记录调用异常方法的栈的调用轨迹并记录在数组中，可通过printStackTrace()打印出来。如果同一个异常对象被连续throw，这个异常会记录下所有的栈轨迹，如果该异常调用fillStackTrace()方法，之间记录的栈轨迹会被清除。不是同一个对象则只记录该对象被抛出的栈轨迹，如果使用不同的异常对象保存完整的栈轨迹，则需要使用case参数或者initCause()方法把一个异常对象的轨迹栈传给另一个异常对象。

5. 在代码中出现异常之后怎么向下执行？将try放入while中，并在finally中使进入异常语句的条件不成立。

6. finally造成异常丢失的情况。try{}finally{}//不使用catch

7. 异常限制，子类重写方法只能声明父类方法抛出的异常及该异常的子类。但构造函数必须抛出父类构造函数声明的异常（默认构造函数除外），但也可以声明其他异常。异常处理的代码是表面的（父类方法中有异常声明，子类方法重写该方法可不写异常声明）。

8. 构造函数中可抛出异常和需要处理异常时，要注意try、catch、finally的合理使用，即能处理异常，也会把资源放开。

9. 被检查异常的使用在项目大的时候会违反设计异常的目的。所以要把被检查异常转换成RuntimeException,在处理的地方通过调用getCause方法获取到原来的异常，进行处理。