1. 泛型是适用于不同类的类型。 

2. 泛型方法中的类型推导，取最小公共超类。

3. 编写一个通用的泛型元组，使该元组可以存储任何指定类型的对象。

4. 使用Set泛型数组实现对象集合的交集、合集、补集、非交集（除去交集之外的地方）。

5. 生成器Generator——泛型和匿名内部类的结合。

6. 使用泛型构建复杂模型（泛型实现嵌套，即泛型使用的是泛型类）

7. 泛型擦除——擦除字段的泛型信息（“匿类型”字段）：向上转型（把泛型作为类型参数，实参信息会被擦除，但是可以保存形参信息，在声明泛型的引用中可以查看泛型的具体信息）。

8. 静态类型检查（编译期间的检查，表面类型检查），泛型具体的类信息在此之后就会被擦除，因为Class类的泛型是擦除的泛型信息，所以可以用Class来恢复泛型信息。

9. 擦除可以实现“迁移兼容性”，把使用泛型的部分单独隔离，和其他的部分不产生关联，“迁移兼容性”是泛型使用擦除实现的原因之一。

10. 泛型编译完之后会如果有泛型返回值，会有转型操作。所有的擦除都是在编译期完成的。

11. 新建一个泛型类：工厂模式（建一个工厂接口，具体类的实现继承该工厂类并使用泛型的具体类型，使用工厂接口创建）;或者使用模板模式。

12. 泛型数组不能被直接创建，但可以通过使用Class类的方式来创建。泛型数组是可以直接使用的。使用元组来创建泛型数组无意义（可以存放任何对象）。

13. 泛型类的继承：父类中有泛型，需要使用子类中的泛型实例（声明或已存在的），若父类中有泛型方法，子类中复写该方法使用子类传给父类的泛型。类*泛型参数*方法的重载是错误的，这时候的泛型是Object，会认为俩个方法是相同的。*泛型参数*方法重载父类的方法是错误的（但可以通过协变来重载该方法，把参数区别开来）。

14. 泛型和型变：用来描述类型转换后的继承关系。

15. 泛型的转型具有不变性，但可以使用通配符(？)实现协变(<? extends Parent>)和逆变（<? super Parent>）。通配符中并不是在Parent继承树下的所有类可以任意使用，他使用的还是一种类，只不过在使用的时候不太关心具体的类是什么，但同时也失去了赋值的能力，这时候的类型参数是null。

16. 当含有类型参数的方法使用通配符时，这个方法参数的类型安全就得不到保障，就不能被调用，除了null。

17. 泛型上界只能get，不能set；下界只能set，不能get。

18. 通配符使接受的类型参数范围更宽，但会功能受损。

19. 捕获转换：通过推导从泛型通配符中推导出泛型确切类，只有在方法调用时才会发生，实参是泛型通配符，形参是泛型确切类。

20. 泛型使用中的问题：不能使用基本类型，但可使用其包装类（自动装箱、拆箱不能用于数组）；在继承树中出现的泛型接口使用的泛型必须是同一个类；转型时转为泛型，实际上是没有效果的，并不是非常安全。

21. 古怪的循环泛型：基类存储子类的一个模板。

22. 自限定就是自己作为自己的边界参数来使用<T extends Self<T>>,自限定实现参数协变。

23. 泛型动态类型安全——在代码中检查参数是否和泛型参数一致。

24. 泛型类不能继承Throwable及其子类，因为类型被擦除掉，所以该类不能被catch到，没有意义。

25. 将多个类的功能混合到一个类中——混型（组合实现）。使用动态代理模式实现多个接口或者类。	

26. 潜在类型的实现：反射。继承类-->接口-->适配器模式。

27. 策略模式